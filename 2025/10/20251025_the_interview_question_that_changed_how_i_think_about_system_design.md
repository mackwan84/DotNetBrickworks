# [改变我对系统设计思考方式的面试问题](https://www.milanjovanovic.tech/blog/the-interview-question-that-changed-how-i-think-about-system-design)

大约六七年前，我参加了一个中级 .NET 开发岗位的面试。

其中一个问题至今仍让我记忆犹新：

> 用户在界面上点击一个按钮来生成 Excel 或 PDF 报告。报告生成过程大约需要五分钟（时间可以是任意的）。用户必须等待它完成。你会如何优化这个流程？

当时，我专注于我最了解的方面：性能。我开始思考如何让报告生成得更快。也许我可以优化 SQL 查询，减少数据转换，或者缓存部分结果。如果我能将这个过程从五分钟缩短到一分钟，那感觉就像是一个巨大的胜利。

但即使我让它快了五倍，用户仍然需要等待。如果浏览器崩溃，他们会失去一切。如果网络中断，进程就会停止。如果他们关闭标签页，所有进度都会消失。

这根本不是性能问题，而是设计问题。

## 我那时错过的东西

回想起来，我意识到自己陷入了"让代码更快"的思维模式。这并不是说这种想法有什么问题，性能优化是一项宝贵的技能。我没有立即看到的是更大的问题。应用程序正在同步执行所有这些工作，将用户作为人质，直到它完成。在面试官的几次提示下，我最终确实想明白了。

![同步报告流程](https://www.milanjovanovic.tech/blogs/mnw_165/sync_reporting_flow.png?imwidth=3840)

更好的问题不是"我怎样才能让这个更快？"

"为什么用户一开始就要等待呢？"

如果某个任务需要几分钟（或几小时、几天）才能完成，它不应该阻塞用户。它应该在后台进行，脱离主要的请求流程，让用户可以继续他们的工作。

不过，别忘了优化代码本身。数据库查询、数据处理和文件生成都很重要。也许有缺失的索引、低效的循环，或者有更好的创建 Excel 文件的库。但这些优化只是解决方案的一部分，而不是全部。

## 我今天会如何解决这个问题

如今，我仍然会从同一个 UI 按钮开始。用户点击"生成报告"，但不需要等待，后端接受请求，将其保存在某处（可能是数据库中的作业记录），然后立即返回。这就是构建异步 API 的本质。然后，该作业会被后台工作程序接收。

这个工作程序可以是托管服务、Quartz 作业，甚至可以是由队列消息触发的 AWS Lambda 函数。它负责处理繁重的工作：提取数据、构建文件，并将其上传到 S3 或 Azure Blob 等存储服务中。

一旦报告准备就绪，工作线程会将作业状态更新为"已完成"并通知用户。这可以是一封包含下载链接的电子邮件，或是在应用中显示的实时 SignalR 消息。该链接指向存储的报告，由后端安全地提供服务。

![异步报告流程](https://www.milanjovanovic.tech/blogs/mnw_165/async_reporting_flow.png?imwidth=3840)

现在，用户不需要等待一个长时间运行的 HTTP 请求。服务器也不会保持连接打开数分钟。如果出现故障，系统可以自动重试。你还可以选择跟踪进度或在需要时取消任务。而且，如果有一百个用户同时请求报告，系统可以扩展而不会锁定。

即使实际报告生成时间没有改变，这种体验感觉更快。因为归根结底，用户并不关心性能指标，他们关心的是响应速度。

## 为什么我仍然使用这个问题

几年后，我开始在面试其他开发者时使用这个完全相同的问题。不是为了刁难任何人，而是因为它能揭示人们的思维方式。

有些候选人直接去优化代码和查询，就像我当时那样。这表明他们熟悉性能调优。我可以继续围绕算法、数据结构或数据库优化提出进一步的技术问题。

其他人会稍作停顿，然后开始思考用户体验、后台处理和容错性。这时真正的对话才刚刚开始：队列、重试机制、通知、安全文件共享等等。你可以通过这一个场景引出更广泛的系统设计讨论，方法有很多种。

没有唯一的标准答案。但只关注代码的人和能够设计可扩展系统的人之间，存在巨大的差异。

## 生动的一课

当我第一次听到这个问题时，我想的是如何让代码运行得更快。现在我想的是如何让体验变得更好。

优化查询或循环可能会有所帮助，但它无法解决等待、故障或可扩展性问题。如果许多用户同时启动相同的报表，同步设计会很快崩溃。无论负载如何，异步流程都能保持系统的响应能力和弹性。

从优化函数到设计可扩展系统的转变，正是优秀开发者与卓越开发者之间的区别。

今天就到这里。希望这些内容对你有帮助。
