# [5 个将立即改善 .NET 项目的隐藏 EF Core Nuget 包](https://antondevtips.com/blog/5-hidden-efcore-nuget-packages)

90% 使用 EF Core 的开发者只使用官方的 NuGet 包。

今天我想向你展示 5 个 EF Core 包，它们提供的功能可以节省时间、减少样板代码并提高性能。

如果你了解它们，这些隐藏的宝藏可以让你的项目更上一层楼。

在本文中，我们将探讨如何：

- 以简洁的方式处理数据库异常
- 自动使你的架构与命名约定保持一致
- 通过大幅提升性能来加速批量操作
- 在运行时执行动态查询
- 通过审计跟踪实体变更

闲话少说，我们开始吧！

## EntityFramework.Exceptions

EF Core 会抛出通用的 DbUpdateException 和 DbUpdateConcurrencyException 。这些错误难以处理。你需要查看内部异常来确定发生了什么。

EntityFramework.Exceptions 将低级数据库错误转换为清晰的、类型化的异常，如 UniqueConstraintException 。这使得在代码、日志和 API 中更容易发现和处理错误。

可用异常列表：

- UniqueConstraintException - 用于唯一约束违反
- CannotInsertNullException - 用于插入语句中的空值
- MaxLengthExceededException - 用于字符串长度违规
- NumericOverflowException - 用于数值溢出
- ReferenceConstraintException - 用于引用约束违规

首先，根据你使用的数据库提供程序从 NuGet 安装相应的包：

```bash
dotnet add package EntityFrameworkCore.Exceptions.SqlServer
dotnet add package EntityFrameworkCore.Exceptions.MySql
dotnet add package EntityFrameworkCore.Exceptions.MySql.Pomelo
dotnet add package EntityFrameworkCore.Exceptions.PostgreSQL
dotnet add package EntityFrameworkCore.Exceptions.Sqlite
dotnet add package EntityFrameworkCore.Exceptions.Oracle
```

你可以在 DbContext 的 OnConfiguring 方法中使用 UseExceptionProcessor 方法来配置并添加类型化异常。

```csharp
public class UserDbContext : DbContext
{
    public DbSet<User> Users { get; set; }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity<User>().HasIndex(user => user.EmailAddress).IsUnique();
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseExceptionProcessor();
    }
}
```

你也可以在 AddDbContext 方法中使用它：

```csharp
builder.Services.AddDbContext<UserDbContext>(options =>
{
    options
        .UseNpgsql(builder.Configuration.GetConnectionString("Postgres"))
        .UseExceptionProcessor();
});
```

DbContextFactory 和 DbContext 池也受支持。

让我们探讨一个如何处理类型化 EF Core 异常的示例。

当用户使用已存在的邮箱注册时，返回 409 Conflict 状态码并附带明确信息：

```csharp
// UniqueConstraintException
using EntityFramework.Exceptions.Common;

app.MapPost("/api/users", async (CreateUserRequest request, UserDbContext db) =>
{
    var user = new User { EmailAddress = request.Email, Name = request.Name };
    db.Users.Add(user);

    try
    {
        await db.SaveChangesAsync();
        
        return Results.Created($"/api/users/{user.Id}",
            new { user.Id, user.EmailAddress, user.Name });
    }
    catch (UniqueConstraintException)
    {
        // e.ConstraintName - 包含被违反的相关约束的名称
        // e.ConstraintProperties - 包含作为约束一部分的属性。
        
        return Results.Conflict(new ProblemDetails
        {
            Title = "Email already exists",
            Detail = "Please use a different email address.",
            Status = StatusCodes.Status409Conflict
        });
    }
});
```

你可以使用 e.ConstraintName 和 e.ConstraintProperties 来记录更详细的错误消息。

> 注意：使用 SQLite 时， ConstraintName 和 ConstraintProperties 将不会被填充。

回顾：EntityFramework.Exceptions 为常见的数据库错误提供了清晰、可操作的异常信息。它减少了样板代码，改进了 API 响应，并使开发人员和客户都能轻松理解故障原因。

## EntityFramework.NamingConventions

在 EF Core 中创建映射时，开发人员通常分为两类：

- 谁会以正确的数据库大小写格式指定列名和表名
- 谁不关心数据库的大小写问题，而 EF Core 会自动生成这些名称

默认情况下，EF Core 会映射到与你的 .NET 类和属性完全同名的表和列。

例如，将一个典型的 User 类映射到 PostgreSQL 将会产生如下 SQL：

```sql
CREATE TABLE "Users" (
    "Id" integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "EmailAddress" text NULL,
    CONSTRAINT "PK_Users" PRIMARY KEY ("Id")
);

SELECT "Id", "EmailAddress"
    FROM "Users"
    WHERE "EmailAddress" = 'test@gmail.com';
```

但这真的是一个问题吗？当然是的。

这是 PostgreSQL 的一个问题，它对表名和列名使用小写 snake_case 。数据库需要在名称周围加上双引号。没有引号的话，PostgreSQL 会将所有名称更改为小写。所有这些引号使代码看起来杂乱且难以阅读。

另一个例子：如果你使用的是 Oracle 数据库，它会以全大写字母的形式使用 UPPER_SNAKE_CASE 的大小写格式。

手写表名和列名真的很繁琐。

你到处添加 HasColumnName() ，仍然可能会遗漏一些：

```csharp
builder.ToTable("users");

builder.Property(x => x.EmailAddress)
    .HasColumnName("email_address")
    .IsRequired();
```

错误的列名很容易悄悄混入数据库迁移中。你需要删除迁移，重新生成它，甚至在数据库中回滚它来修复列名。

EntityFramework.NamingConventions 包可以解决这个问题。

此包为 EF Core 创建的所有表、列、键和索引应用全局命名约定。

你可以切换到 snake_case 、 lowercase 、 UPPER_SNAKE_CASE 、 UPPERCASE ，或保留 PascalCase ——而无需为每个实体手动指定。

要开始使用，请从 NuGet 安装该包：

```bash
dotnet add package EFCore.NamingConventions
```

在注册 DbContext 时启用约定：

```csharp
using Microsoft.EntityFrameworkCore;

builder.Services.AddDbContext<AppDbContext>(options =>
{
    options
        .UseNpgsql(builder.Configuration.GetConnectionString("Postgres"))
        .UseSnakeCaseNamingConvention(); // or .UseUpperCaseNamingConvention()
                                         // or .UseUpperSnakeCaseNamingConvention()
                                         // or .UseCamelCaseNamingConvention()
                                         // or .UseLowerCaseNamingConvention()
});
```

这将自动使你的所有表名和列名都采用小写 snake_case 命名：

```csharp
public class User
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
    public string EmailAddress { get; set; } = default!;
    public ICollection<UserLogin> Logins { get; set; } = new List<UserLogin>();
}

public class UserLogin
{
    public int Id { get; set; }
    public int UserAccountId { get; set; }
    public DateTime SignedInAt { get; set; }
    public UserAccount User { get; set; } = default!;
}
```

使用 .UseSnakeCaseNamingConvention() ，EF Core 将创建如下名称：

- 表： user_account , user_login
- 列： created_at , email_address , user_account_id , signed_in_at
- 索引/键：例如， IX_user_login_user_account_id

支持的命名约定：

- UseSnakeCaseNamingConvention: FullName 变为 full_name
- UseLowerCaseNamingConvention: FullName 变为 fullname
- UseCamelCaseNamingConvention: FullName 变为 fullName
- UseUpperCaseNamingConvention: FullName 变为 FULLNAME
- UseUpperSnakeSnakeCaseNamingConvention: FullName 变为 FULL_NAME

回顾：EntityFramework.NamingConventions 为你提供了一种简单的方法，可以为 EF Core 创建的所有表、列、键和索引应用命名约定，而无需为每个实体手动指定。

## Entity Framework Extensions

在 Entity Framework Core 中处理大型数据集时，开发人员经常遇到使用 SaveChanges() 的性能瓶颈。

每次实体插入都会触发一次单独的数据库往返，并由于实体跟踪开销而增加内存使用量。随着行数增长到数千或数百万，这种情况变得更加明显。

我们该如何提高插入性能？

- 使用 Dapper？不行，因为它也会将每次插入作为单独的往返操作发送到数据库。
- 也许使用 SqlBulkCopy？那并不理想，因为你需要大量自定义代码，特别是当你想要插入子实体或返回标识值时。

而且它只适用于 SQL Server，所以如果你需要支持其他提供程序，它就不太合适。

有一个更好的解决方案：Entity Framework Extensions 库。

这个库为批量插入提供了更简单、更优雅和可配置的选项。

要开始使用 Entity Framework Extensions，请安装以下 NuGet 包：

```bash
dotnet add package Z.EntityFramework.Extensions.EFCore
```

Entity Framework Extensions 允许你用一行代码批量插入数千个实体：

```csharp
using Z.EntityFramework.Extensions;

var products = GenerateProducts(10_000);
await dbContext.BulkInsertAsync(products);
```

BulkInsert 和 BulkInsertAsync 方法均可用。

让我们比较一下批量插入方法的性能，使用 SaveChanges ：

- 插入：速度快 14 倍，在线基准测试中时间减少 93%
- 更新：速度快 4 倍，在线基准测试中时间减少 75%
- 删除：速度快 3 倍，在线基准测试中时间减少 65%

我已通过 Web API 测试了以下数据库查询：

```csharp
using Z.EntityFramework.Extensions;

app.MapPost("/products/efcore-insert", async (ProductDbContext dbContext) =>
{
    var products = GenerateProducts(10_000);
    dbContext.Products.AddRange(products);

    await dbContext.SaveChangesAsync();

    return Results.Ok("10,000 products inserted using EF Core SaveChanges.");
});

app.MapPost("/products/efcore-bulk-insert", async (ProductDbContext dbContext) =>
{
    var products = GenerateProducts(10_000);
    await dbContext.BulkInsertAsync(products);

    return Results.Ok("10,000 products inserted using Bulk Insert of EF Core Extensions.");
});

app.MapPost("/products/efcore-bulk-insert-optimized", async (ProductDbContext dbContext) =>
{
    var products = GenerateProducts(10_000);
    var result = await dbContext.BulkInsertOptimizedAsync(products);

    return Results.Ok(result);
});
```

我在 Postgres 数据库上测试了这些查询，以下是通过 Web API 请求插入 10,000 个产品的结果：

- SaveChanges - 2,011 毫秒
- BulkInsert - 560 毫秒
- BulkInsertOptimized - 270 毫秒

> 注意：基准测试结果可能会因你的硬件和数据库提供商而有所不同。

Entity Framework Extensions 支持以下批量写入方法：

- BulkInsert, BulkInsertAsync
- BulkInsertOptimized, BulkInsertOptimizedAsync
- BulkUpdate, BulkUpdateAsync
- BulkDelete, BulkDeleteAsync
- BulkMerge, BulkMergeAsync
- BulkSynchronize, BulkSynchronizeAsync

Entity Framework Extensions 支持以下数据库提供程序：

- SQL Server
- MySQL
- MariaDB
- Oracle
- PostgreSQL
- SQLite

## EntityFramework.DynamicFilters

有时你无法在编译时编写 LINQ。你需要根据用户输入（如网格、搜索页面和报表）在运行时构建筛选器、排序和投影。

Microsoft.EntityFrameworkCore.DynamicLinq 为 EF Core 添加了基于字符串的 LINQ，因此你可以使用类似 Price > 100 && Category == @0 的表达式调用 Where 、 OrderBy 、 Select 等。

要开始使用，请从 NuGet 安装该包：

```bash
dotnet add package Microsoft.EntityFrameworkCore.DynamicLinq
```

当使用 Dynamic LINQ 查询数据时，所有内容都可以用字符串表示。这包括谓词、选择器和排序。

强类型 LINQ 看起来像：

```csharp
var result = context.Users
    .Where(c => c.EmailAddress == "test@test.com")
    .ToList();
```

Dynamic LINQ 看起来像这样：

```csharp
var resultDynamic = context.Users
    .Where("EmailAddress == \"test@test.com\"")
    .ToList();
```

无需将值指定为硬编码值；你可以使用参数：

```csharp
var email = "test@test.com";

var resultDynamic = context.Users
    .Where("EmailAddress == @0", email)
    .ToList();
```

这是一个更复杂的查询。你可以从 Web API 请求中获取用户数据：

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.DynamicLinq;

// 来自 UI / 查询字符串的运行时值
string filter = "Price >= @0 && Category == @1";
object[] args = { 100m, "Books" };
string orderBy = "Price desc, Title";
string selector = "new (Id, Title, Price)";

var query = db.Products
    .Where(filter, args)          // 动态 谓词
    .OrderBy(orderBy)             // 动态 排序
    .Select(selector);            // 动态 投影

var items = await query.ToListAsync(); // 异步执行
```

## Audit.EntityFramework.Core

手动记录谁在何时更改了什么内容是一项繁琐的工作。编写包含旧值/新值和用户信息的变更日志既耗时又容易遗漏。

Audit.EntityFramework.Core 插入到 EF Core 中，自动记录实体变更（插入、更新、删除）。你会获得一份完整的审计跟踪，可以将其存储或发送到任何地方。

要开始使用，请从 NuGet 安装该包：

```bash
dotnet add package Audit.EntityFramework.Core
```

要审计插入、删除和更新操作，你可以使用提供的三种 SaveChanges 拦截机制中的任何一种：

### 继承自 AuditDbContext

```csharp
// 继承自 Audit.EntityFramework.AuditDbContext
public class UserDbContext : AuditDbContext
{
    public DbSet<User> Users { get; set; }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity<User>().HasIndex(user => user.EmailAddress).IsUnique();
    }
}
```

> 注意：如果你使用的是 IdentityDbContext 而不是 DbContext ，你可以安装 Audit.EntityFramework.Identity.Core 包并继承 AuditIdentityDbContext 类，而不是 AuditDbContext 。

### 覆盖 SaveChanges

你可以在不更改 DbContext 继承的情况下使用该库。你可以覆盖 SaveChanges 和 SaveChangesAsync ：

```csharp
public class UserDbContext : DbContext
{
    private readonly DbContextHelper _helper = new DbContextHelper();
    private readonly IAuditDbContext _auditContext;

    public UserDbContext(DbContextOptions<UserDbContext> options) : base(options)
    {
        _auditContext = new DefaultAuditContext(this);
        _helper.SetConfig(_auditContext);
    }

    public override int SaveChanges(bool acceptAllChangesOnSuccess)
    {
        return _helper.SaveChanges(_auditContext, () => base.SaveChanges(acceptAllChangesOnSuccess));
    }

    public override async Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess,
        CancellationToken cancellationToken = default(CancellationToken))
    {
        return await _helper.SaveChangesAsync(_auditContext,
            () => base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken), cancellationToken);
    }
}
```

### 创建保存更改拦截器

或者，你可以创建一个保存更改拦截器并将其注册到 EF Core 中：

```csharp
public class UserDbContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.AddInterceptors(new AuditSaveChangesInterceptor());
    }
}
```

或者在注册 DbContext 时添加 AuditSaveChangesInterceptor ：

```csharp
builder.Services.AddDbContext<UserDbContext>(options =>
{
    options
        .UseNpgsql(builder.Configuration.GetConnectionString("Postgres"))
        .AddInterceptors(new AuditSaveChangesInterceptor())
});
```

要存储审计事件，你需要在 EF Core 中配置一个数据提供程序：

```csharp
Audit.Core.Configuration.Setup()
    .UseEntityFramework(ef => ef
        .UseDbContext<OrderDbContext>()
        .AuditTypeExplicitMapper(m => m
            .Map<Order, OrderAudit>()
            .Map<Orderline, OrderlineAudit>()
            .AuditEntityAction<IAudit>((evt, entry, auditEntity) =>
            {
                auditEntity.AuditDate = DateTime.UtcNow;
                auditEntity.UserName = evt.Environment.UserName;
                auditEntity.AuditAction = entry.Action; // 插入、更新、删除
            })
        )
    );
```

建议为审计使用单独的 DbContext 。

因此，你将在数据库中得到以下数据库架构：

![数据表结构](https://antondevtips.com/media/code_screenshots/efcore/5_hidden_packages/img_1.png)

今天就到这里。期待与你再次相见。
