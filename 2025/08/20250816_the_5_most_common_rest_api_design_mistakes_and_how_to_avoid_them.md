# [五种最常见的 REST API 设计错误（以及如何避免它们）](https://www.milanjovanovic.tech/blog/the-5-most-common-rest-api-design-mistakes-and-how-to-avoid-them)

糟糕的 API 会给开发者带来阻力，增加维护成本，并使变更变得风险重重。良好的 API 设计并不意味着盲目遵循每一条"最佳实践"。它意味着为你的具体情况选择合适的权衡方案，并坚持这些方案。

以下是我反复看到的 5 个常见错误，它们为何会导致问题，以及如何通过实用且经过实战检验的解决方案来避免它们。

## 1. 不一致的命名和结构

命名是消费者首先看到的东西。这里的不一致性会导致频繁查阅文档、破坏期望以及更多错误。

听着，我们都经历过这种情况。你成功调用了 **/users** 和 **/products** ，所以很自然地你尝试了 **/orders** 。但不行，这个 API 出于某种原因使用了 **/order-list** 。现在你又得回去查看文档，打断了你的思路，试想一下谁愿意想知道为什么会这样。将这种摩擦乘以几十个端点，你就构建了一个让开发者想要掀桌子的 API。

我理解，像 **/users/{id}/habits/{habitId}/entries/{entryId}/comments/{commentId}** 这样的深层 URL 层次结构让人感觉很满足。它们反映了你漂亮的领域模型！但问题是：你刚刚将整个数据结构硬编码到了 URL 中。当业务需求发生变化（而且它们一定会变化）时，你无法在不破坏客户端的情况下重新组织。

此外，当某人只有一个评论 ID 时会发生什么？他们需要以某种方式找出用户、习惯和条目的 ID，仅仅是为了获取一条评论。这太荒谬了。

保持简单，使用复数名词： **/users** 、 **/habits** 、 **/entries** 。不再需要猜测是 **user** 还是 **users** 。

只有在某物真正属于另一物时才进行嵌套。用户设置属于用户并随用户一起消失，因此 **/users/{id}/settings** 是有意义的。评论可以独立存在，因此 **/users/{id}/posts/{postId}/comments** 可以简化。

相反，使用过滤器进行扁平化处理：

```bash
# 与其使用深层嵌套
GET /users/{userId}/habits/{habitId}/entries

# 不如使用过滤器
GET /entries?userId={userId}&habitId={habitId}
GET /entries?habitId={habitId}  # 现在你可以在不知道用户的情况下获取条目
```

而且，拜托，看在上帝的份上，请包装好你的数组：

```json
{
  "data": [
    {
      "id": "e_8YH",
      "habitId": "code-review",
      "at": "2025-08-08T09:17:34Z",
      "value": 5,
      "unit": "reviews",
      "tags": ["team"]
    },
    {
      "id": "e_8Z2",
      "habitId": "deep-work",
      "at": "2025-08-07T07:00:00Z",
      "value": 2,
      "unit": "pomodoros",
      "note": "EF filters optimized"
    }
  ],
  "total": 42,
  "hasMore": true,
  "nextCursor": "cursor_01J9KaBcd"
}
```

我知道现在这感觉像是毫无意义的样板代码，但请相信我，当六个月后你需要添加分页信息时，你会感谢自己不必破坏所有期望原始数组的客户端。

是的，REST 纯粹主义者会抱怨过滤器不够"RESTful"。随他们去吧。你的 API 将会是灵活的、可维护的，并且实际上使用起来很愉快。我宁愿选择这些，而不是概念上的纯粹性。

## 2. 糟糕的版本控制策略

每个人都默认使用版本控制（ **/v1/users** ），认为他们能聪明地应对未来的变化。剧透：他们并没有。他们正在制造一个维护噩梦。

当你同时运行 v1、v2 和 v3 版本时，实际会发生以下情况：

- 每个错误需要修复三次
- 每个安全补丁都需要三次部署
- 你的文档变成了一本选择你自己的冒险小说
- 支持团队完全不知道那位愤怒的客户正在使用哪个版本
- 你花周末的时间维护两年前写的代码

但最糟糕的部分是什么？版本控制会让你变得懒惰。你不再思考"如何在不破坏客户端的情况下进行演进？"，而是想"嗯，我会增加版本号。"现在你的客户端不得不重写他们的整个集成，只因为你想要重命名字段。

看看这场灾难如何展开：

```bash
v1: GET /users returns {id, name, email}
v2: GET /users returns {id, fullName, emailAddress}  // 看起更干净了
v3: GET /users returns {id, firstName, lastName, email}  // 我们需要拆分名字！
```

恭喜，你现在要为同一该死的数据维护三种不同的响应格式。那个 v1 客户端？除非他们重写所有代码，否则永远无法获得新功能。发现了一个关键错误？希望你喜欢打三次补丁！

这是一个激进的想法：完全不要版本控制。我是认真的。

添加字段，不要替换它们：

```json
// 一开始是这样的
{ "id": 1, "name": "John Doe" }

// 后来你发布的内容（保留旧字段）
{
  "id": 1,
  "name": "John Doe",  // 仍然存在！在文档中标记为不推荐使用
  "firstName": "John",
  "lastName": "Doe"
}
```

需要可选功能？使用查询参数：

```bash
GET /users/{id}?include=habits,entries
GET /users/{id}?format=detailed
```

如果你必须做出破坏性变更（并且请认真考虑这一点），请创建一个新资源：

```bash
# 旧的接口，保留
GET /users/{id}

# 新的接口
GET /userProfiles/{id}
```

当破坏性变更确实无法避免时，至少要表现得体面一些。提前 6-12 个月通知用户。同时运行两个版本。编写一份实用的迁移指南。看在上帝的份上，监控谁仍在使用旧版本，这样你就可以在停止支持前联系他们。

是的，这意味着你需要提前认真思考 API 设计。你不能随意命名字段然后以后再修改。但这种约束会让你设计出更好的 API，未来的你会请现在的你喝一杯啤酒。

如果你想了解更多关于这方面的内容，我推荐阅读这篇[文章](https://medium.com/good-api/api-change-management-2fe5bba32e9b)。

## 3. 忽略分页、过滤和搜索

那个 GET **/entries** 端点在你的 10 条测试记录上运行得很好。然后你上线了，获得了真实用户，突然间你在单个响应中返回了 100,000 个条目。你的 API 超时了，那些连接不佳的移动用户讨厌你，而你的云账单让你想哭。

"我们稍后会添加分页，"你曾说过。好吧，现在就是那个"稍后"了，而添加分页意味着破坏所有期望数组的客户端。干得漂亮。

没有过滤功能，你的客户端需要下载数千条记录才能找到他们实际需要的五条。这就像让某人下载整个维基百科只为了读一篇文章。你的服务器正在熔化，序列化没人需要的数据。你的用户正在耗尽他们的数据流量。所有人都输了。

**过滤**适用于当你确切知道自己想要什么的情况：

```bash
GET /entries?habitId=123&date=2025-08-01&status=completed
```

**搜索**适用于你大概知道自己想要什么的情况：

```bash
GET /entries/search?q=morning+run+park
```

不要试图耍聪明将它们结合起来。过滤能高效利用数据库索引。搜索需要全文检索的魔法。将两者混合，最终会得到一个两者都做不好的东西。

对于分页，你有两种选择，它们在不同方面都有些糟糕。

**offset** / **limit** 是每个人都会从这开始的方法：

```bash
GET /entries?offset=100&limit=50
             # 或者叫 skip / take
             # 又或者叫 page / pageSize
```

这非常简单，让用户可以直接跳到第 5 页，但有趣的部分来了：当有人在分页浏览时添加或删除项目，他们要么会跳过一些条目，要么会看到重复的内容。此外，请求 offset=10000 会让你的数据库崩溃，因为它需要计算所有这些行。

**基于游标的分页**是"正确"的解决方案：

```bash
GET /entries?limit=50&cursor=eyJpZCI6MTIzfQ==
```

坚如磐石，不会跳过项目，性能一致。但你无法跳转到任意页面，如果底层数据发生重大变化，游标可能会失效。

是的，实现所有这些都很麻烦。你需要游标编码、参数验证、查询优化。但试图在发布后添加这些功能？不建议这样做。最好第一次就把它做对。

## 4. 不清晰或不一致的错误处理

{"error": "An error occurred"} — 如果你返回这个，我讨厌你。

说真的，当你的 API 输出这些无用的错误时，会发生这样的情况：我会随机尝试各种方法，希望能碰巧找到有效的。我会在各处添加防御性代码，因为我不信任你。我会涌向你的支持渠道询问出了什么问题。然后我会在社交媒体上抱怨你的 API（任何宣传都是正面的，真的是这样吗？）。

一个好的错误信息应该告诉我三件事：哪里出错了，为什么会出错，以及如何修复它。这有那么难吗？

别再发明你自己那蹩脚的错误格式了。像文明的开发者一样使用**Problem Details**（RFC 9457）：

```json
{
  "type": "https://api.example.com/errors/validation-failed",
  "title": "Validation Failed",
  "status": 400,
  "detail": "The request body contains invalid fields",
  "instance": "/habits/123",
  "errors": [
    {
      "field": "name",
      "reason": "Must be between 1 and 100 characters",
      "value": ""
    },
    {
      "field": "frequency",
      "reason": "Must be one of: daily, weekly, monthly",
      "value": "sometimes"
    }
  ]
}
```

看到这实际上是如何帮助我解决问题的？革命性的，我知道。

并且请使用正确的状态码。这并不难：

- **400 Bad Request** : 你发送了垃圾数据
- **401 Unauthorized** : 你是谁？
- **403 Forbidden** ：我知道你是谁，但是不行
- **404 Not Found** : 那个东西不存在
- **409 Conflict** : 这与某些内容相冲突
- **422 Unprocessable Entity** : 我明白你想要什么，但这是错误的
- **429 Too Many Requests** : 悠着点，太快了
- **500 Internal Server Error** : 我们搞砸了
- **503 Service Unavailable** : 我们忙不过来了，请稍后再试

现在，别像新手那样在生产环境中泄露完整的堆栈跟踪。向用户提供友好的错误信息，在开发/测试环境中提供详细的错误，并将那些血淋淋的细节记录在服务器端，这样你才能真正利用它们。

## 5. 直到为时已晚才重视安全问题

"我们会在第二阶段添加认证"——在你的 API 成为黑客数据盛宴之前的最后名言。问问 Tea 应用这对他们来说效果如何。

当你试图在后期添加安全性时，会发生以下情况：当你添加身份验证时，每个客户端都会崩溃。你一直在泄露的那些数据？可能已经被抓取了。你的合规审计？失败了。那一次安全事件？你的用户会提起好几年。

身份验证（你是谁？）和授权（你能做什么？）是不同的概念。我见过太多 API 只检查你是否登录，却从不检查你是否真的有权访问那些数据。别成为那样的人。

速率限制不仅仅是防止滥用，更是为了公平。从简单开始：每个 API 密钥每小时 1000 次请求。当达到限制时，返回 429 并在头部显示何时可以重试。然后变得更精细：为不同端点设置不同限制，为付费客户提供更高限制，为那个一直做奇怪操作的客户设置更低限制。

HTTPS 无处不在。是的，即使是你的内部"没人会发现这个"的 API。现在是 2025 年，不是 2005 年。Let's Encrypt 是免费的。你没有借口。

看，安全性会让事情变得更慢、更复杂。每次请求的身份验证检查、加密开销、用于速率限制的状态管理，这一切都会累积。但你知道什么更糟糕吗？向你的用户解释为什么他们的数据正在暗网上被出售。从一开始就构建安全性，否则就要准备迎接痛苦的世界。

## 最后的思考

良好的 API 设计并非追求完美，而是做出有意识、有根据的决策。每个选择都是一种权衡。一致性可能会限制灵活性。安全性会影响性能。稳定性意味着创新速度较慢。

真正重要的是：了解你的权衡并接受它们。记录你做出这些选择的原因（未来的你会感谢你）。即使在不情愿的时候也要保持一致性。为演进而设计，而不是为某个想象中的完美未来。倾听你的用户，但不要为了取悦每个人而把你的 API 变成一个弗兰肯斯坦式的怪物。

你的 API 是对其他开发者的承诺。每当你打破这个承诺（通过破坏性变更、不一致的模式或无用的错误信息），你就会失去他们的信任。相信我，开发者们会记仇的。

构建你自己也愿意使用的 API。你的开发者会感谢你，你的支持团队会感谢你，而且说实话，六个月后当你不得不维护这个东西时，你也会感谢自己。

今天就到这里。期待与你再次相见。
